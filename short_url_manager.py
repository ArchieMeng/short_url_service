import random
import os
import json
import multiprocessing


class ShortUrlManager:
    RECORD_NAME = 'records.json'
    record_lock = multiprocessing.Lock()
    
    def __init__(self, host_name, port=80, url_len=6, rand_num_generator=lambda: os.urandom(16)):
        self.host_name, self.port = host_name, port
        self.len = url_len

        try:
            with open(ShortUrlManager.RECORD_NAME, 'r') as rf:
                records = json.load(rf)
                self.key2url = records['key2url']
                self.url2key = {self.key2url[key]: key for key in self.key2url}

        except FileNotFoundError:
            self.url2key, self.key2url = dict(), dict()

        self.generate_random_bytes = rand_num_generator
        self.char_list = [str(i) for i in range(10)] +\
                         [chr(i + ord('a')) for i in range(26)] +\
                         [chr(i + ord('A')) for i in range(26)]

    def dump_map(self):
        with open(ShortUrlManager.RECORD_NAME, 'w') as wf:
            json.dump(
                {
                    # 'url2key': self.url2key,
                    'key2url': self.key2url
                },
                wf
            )

    def __generate_short_key(self, url: str):
        while True:
            random.seed(self.generate_random_bytes() + url.encode())
            short_key = ''
            for i in range(self.len):
                short_key += random.choice(self.char_list)
                
            if short_key not in self.key2url:
                return short_key
            
    def __key_to_url(self, key):
        if self.port != 80:
            return 'http://{host}:{port}/{key}'.format(
                host=self.host_name,
                port=self.port,
                key=key
            )
        else:
            return 'http://{host}/{key}'.format(
                host=self.host_name,
                key=key
            )
        
    @staticmethod
    def __short_url_to_key(url: str):
        return url.split('/')[-1]
        
    def get_short_url(self, url):
        if url in self.url2key:
            return self.__key_to_url(self.url2key[url])
        else:
            with ShortUrlManager.record_lock:
                short_key = self.__generate_short_key(url)
                self.url2key[url] = short_key
                self.key2url[short_key] = url

            # start another thread to store map records
            dump_process = multiprocessing.Process(target=self.dump_map)
            dump_process.daemon=False
            dump_process.start()

            return self.__key_to_url(short_key)
    
    def get_url(self, key):
        """
        get original url by key

        :param key: short key which is generated by this manager

        :return: if key is valid, return url, else return None
        """
        if len(key) == self.len and key in self.key2url:
            return self.key2url[key]
        else:
            return None


if __name__ == '__main__':
    # testing
    manager = ShortUrlManager('localhost')

    print('It should print None because no key in it')
    print(manager.get_url('fucka'))
    print(manager.get_url('fucka2'))
    print()

    print('It should print 4 line with duplicate short_url')
    print(manager.get_short_url('https://www.baidu.com'))
    print(manager.get_short_url('https://www.baidu.com'))
    print(manager.get_short_url('https://www.google.com'))
    print(manager.get_short_url('https://www.google.com'))
    print()

    print('It should print 2 original url')
    print(manager.get_url(manager.get_short_url('https://www.baidu.com').split('/')[-1]))
    print(manager.get_url(manager.get_short_url('https://www.google.com').split('/')[-1]))
    print()

    print('It should print None because the length of this key does not match manager.len')
    print(manager.get_url('fucka'))
    print('It should print None if it is not in manager')
    print(manager.get_url('fucka2'))